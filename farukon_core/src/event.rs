// farukon_core/src/event.rs

//! Event system: defines messages passed between components.
//! Uses trait-based polymorphism to handle MARKET, SIGNAL, ORDER, FILL uniformly.
//!
//! Components (DataHandler, Strategy, Portfolio, Execution) communicate via events.
//! Events are sent through channels and processed in FIFO order.
//! This decouples components and enables modularity and speed.

pub trait Event: std::fmt::Debug + Send + Sync {
    /// Returns the type of the event as a static string.
    fn event_type(&self) -> &'static str;
    /// Returns a reference to the SignalEvent parameters, if this is a SignalEvent.
    fn get_signal_event_params(&self) -> Option<&SignalEvent>;
    /// Returns a reference to the OrderEvent parameters, if this is an OrderEvent.
    fn get_order_event_params(&self) -> Option<&OrderEvent>;
        /// Returns a reference to the FillEvent parameters, if this is a FillEvent.
    fn get_fill_event_params(&self) -> Option<&FillEvent>;
}

// --- MARKET EVENT ---

/// Represents a new market bar arriving.
/// Triggered by the DataHandler when new data is available.
#[derive(Debug)]
pub struct MarketEvent;

impl MarketEvent {
    /// Creates a new MarketEvent.
    pub fn new() -> Self {
        Self
    }
    
}

impl Event for MarketEvent {
    fn event_type (&self) -> &'static str {
        "MARKET"
    }

    fn get_signal_event_params(&self) -> Option<&SignalEvent> {
        None
    }

    fn get_order_event_params(&self) -> Option<&OrderEvent> {
        None
    }

    fn get_fill_event_params(&self) -> Option<&FillEvent> {
        None
    }

}

// --- SIGNAL EVENT ---

/// Represents a signal generated by a strategy.
/// Signals indicate an intent to trade (e.g., "LONG", "SHORT", "EXIT").
#[derive(Debug)]
pub struct SignalEvent {
    /// The timestamp of the order.
    pub timeindex: chrono::DateTime<chrono::Utc>,
    /// The name of the signal that triggered the order.
    pub symbol: String,
    /// The name of the signal that triggered the order.
    pub signal_name: String,
    /// The type of order to place ("MKT" for market, "LMT" for limit).
    pub order_type: String,
    /// The quantity to trade.
    pub quantity: Option<f64>,
    /// The limit price (optional, only for limit orders).
    pub limit_price: Option<f64>,
}

impl SignalEvent {
    pub fn new(
        timeindex: chrono::DateTime<chrono::Utc>,
        symbol: String,
        signal_name: String,
        order_type: String,
        quantity: Option<f64>,
        limit_price: Option<f64>,
    ) -> Self {
        Self {
            timeindex,
            symbol,
            signal_name,
            order_type,
            quantity,
            limit_price,
        }
    }

}

impl Event for SignalEvent {
    /// Creates a new SignalEvent.
    /// # Arguments
    /// * `timeindex` - The timestamp of the signal.
    /// * `symbol` - The symbol to trade.
    /// * `signal_name` - The name of the signal.
    /// * `order_type` - The type of order to place.
    /// * `quantity` - The quantity to trade.
    /// * `limit_price` - The limit price.
    fn event_type (&self) -> &'static str {
        "SIGNAL"
    }

    fn get_signal_event_params(&self) -> Option<&SignalEvent> {
        Some(self)
    }

    fn get_order_event_params(&self) -> Option<&OrderEvent> {
        None
    }

    fn get_fill_event_params(&self) -> Option<&FillEvent> {
        None
    }

}

// --- ORDER EVENT ---

/// Represents an order to be executed.
/// Created by the Portfolio based on a SignalEvent.
#[derive(Debug)]
pub struct OrderEvent {
    /// The timestamp of the order.
    pub timeindex: chrono::DateTime<chrono::Utc>,
    /// The name of the signal that triggered the order.
    pub symbol: String,
    /// The name of the signal that triggered the order.
    pub signal_name: String,
    /// The type of order ("MKT" for market, "LMT" for limit).
    pub order_type: String,
    /// The quantity to trade.
    pub quantity: f64,
    /// The direction of the order (optional, "BUY" or "SELL").       
    pub direction: Option<String>,
    /// The limit price (optional, only for limit orders).
    pub limit_price: Option<f64>,
}

impl OrderEvent {
    pub fn new(
        timeindex: chrono::DateTime<chrono::Utc>,
        symbol: String,
        order_type: String,
        quantity: f64,
        direction: Option<String>,
        signal_name: String,
        limit_price: Option<f64>,
    ) -> Self {
        Self {
            timeindex,
            symbol,
            signal_name,
            order_type,
            quantity,
            direction,
            limit_price,
        }
    }

}

impl Event for OrderEvent {
    /// Creates a new OrderEvent.
    /// # Arguments
    /// * `timeindex` - The timestamp of the order.
    /// * `symbol` - The symbol to trade.
    /// * `order_type` - The type of order.
    /// * `quantity` - The quantity to trade.
    /// * `direction` - The direction of the order.
    /// * `signal_name` - The name of the signal.
    /// * `limit_price` - The limit price.
    fn event_type (&self) -> &'static str {
        "ORDER"
    }

    fn get_signal_event_params(&self) -> Option<&SignalEvent> {
        None
    }

    fn get_order_event_params(&self) -> Option<&OrderEvent> {
        Some(self)
    }

    fn get_fill_event_params(&self) -> Option<&FillEvent> {
        None
    }

}

// --- FILL EVENT ---

/// Represents a filled order.
/// Created by the ExecutionHandler after successfully executing an OrderEvent.
#[derive(Debug)]
pub struct FillEvent {
    /// The timestamp of the fill.
    pub timeindex: chrono::DateTime<chrono::offset::Utc>,
    /// The symbol that was traded.
    pub symbol: String,
    /// The exchange where the trade occurred.
    pub exchange: String,
    /// The quantity that was traded.
    pub quantity: f64,
    /// The direction of the trade (optional, "BUY" or "SELL").
    pub direction: Option<String>,
     /// The execution price of the trade.
    pub execution_price: Option<f64>,
    /// The commission charged for the trade.
    pub commission: Option<f64>,
    /// The name of the signal that triggered the order.
    pub signal_name: String,
}

impl FillEvent {
    /// Creates a new FillEvent.
    /// # Arguments
    /// * `timeindex` - The timestamp of the fill.
    /// * `symbol` - The symbol that was traded.
    /// * `exchange` - The exchange where the trade occurred.
    /// * `quantity` - The quantity that was traded.
    /// * `direction` - The direction of the trade.
    /// * `execution_price` - The execution price of the trade.
    /// * `commission` - The commission charged for the trade.
    /// * `signal_name` - The name of the signal that triggered the order.
    pub fn new(
        timeindex: chrono::DateTime<chrono::offset::Utc>,
        symbol: String,
        exchange: String,
        quantity: f64,
        direction: Option<String>,
        execution_price: Option<f64>,
        commission: Option<f64>,
        signal_name: String,
    ) -> Self {
        Self {
            timeindex,
            symbol,
            exchange,
            quantity,
            direction,
            execution_price,
            commission,
            signal_name,
        }
    }
    
}

impl Event for FillEvent {  
    fn event_type (&self) -> &'static str {
        "FILL"
    }

    fn get_signal_event_params(&self) -> Option<&SignalEvent> {
        None
    }

    fn get_order_event_params(&self) -> Option<&OrderEvent> {
        None
    }

    fn get_fill_event_params(&self) -> Option<&FillEvent> {
        Some(self)
    }

}
